# -*- coding: utf-8 -*-
"""Exercise_2_Boston_House_Prices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eIA6uRkZcAyj5IiYrj0gm-XtN1u2thWo

这个数据集是 20 世纪 70 年代中期美国波士顿郊区房屋价格。已知当时郊区的一些数据点，比如犯罪率、房产税率等等，一共13个。本期用到的数据集有506条，分为404条训练数据和102条测试数据。我们先用训练数据来训练网络模型，然后用测试数据来验证模型的预测效果。

Tensorflow 框架已经把这个数据集做了封装。我们只需要导入该库，执行函数，就能自动下载使用了。
"""

from tensorflow.keras.datasets import boston_housing
from tensorflow.keras import models, layers

# 调用函数，载入数据
(train_data, train_targets), (test_data, test_targets) = boston_housing.load_data()

print(train_data.shape)
print(test_data.shape)

data = train_data[0]
print('人均犯罪率\t', data[0])
print('住宅密度 \t', data[1])
print('商业配套 \t', data[2])
print('空气质量 \t', data[3])
print('河流覆盖 \t', data[4])
print('房屋大小 \t', data[5])
print('房屋年龄 \t', data[6])
print('城区距离 \t', data[7])
print('交通距离 \t', data[8])
print('住宅税率 \t', data[9])
print('教育资源 \t', data[10])
print('人口肤色比例 \t', data[11])
print('人口密度 \t', data[12])

print('\n\n打印结果数据')
print('房屋价格 \t', train_targets[0])

"""归一化处理：用每个数据减去特征的平均值，再除以标准差。"""

mean = train_data.mean(axis=0)
std = train_data.std(axis=0)

train_data -= mean
train_data /= std

test_data -= mean
test_data /= std

data = train_data[0]
print('人均犯罪率\t', data[0])
print('住宅密度 \t', data[1])
print('商业配套 \t', data[2])
print('空气质量 \t', data[3])
print('河流覆盖 \t', data[4])
print('房屋大小 \t', data[5])
print('房屋年龄 \t', data[6])
print('城区距离 \t', data[7])
print('交通距离 \t', data[8])
print('住宅税率 \t', data[9])
print('教育资源 \t', data[10])
print('人口肤色比例 \t', data[11])
print('人口密度 \t', data[12])

model = models.Sequential()                     # 定义一个连续的网络模型
model.add(layers.Dense(64, input_shape=(13,)))  # 添加一个输入层，指定输入形状是13个数
model.add(layers.Dense(1))                      # 添加一个输出层
model.compile(optimizer='sgd', loss='mse', metrics=['mae'])   # 编译模型
model.summary()   # 打印模型结构

model.fit(
  train_data,     # 训练特征数据
  train_targets,  # 训练结果数据
  epochs=100,     # 训练测试
  verbose=0       # 隐藏训练日志
)

val_mse, val_mae = model.evaluate(test_data, test_targets, verbose=0)  # 验证测试数据集
print(val_mae)                                                         # 输出平均误差

model = models.Sequential()                     # 定义一个连续的网络模型
model.add(layers.Dense(64,
                       activation='relu',
                       input_shape=(13,)))      # 添加一个输入层，并设置激活函数
model.add(layers.Dense(1))                      # 添加一个输出层
model.compile(optimizer='sgd', loss='mse', metrics=['mae'])   # 编译模型
model.summary()                                 # 打印模型结构

model.fit(train_data, train_targets, epochs=100, verbose=0)            # 训练数据
val_mse, val_mae = model.evaluate(test_data, test_targets, verbose=0)  # 验证测试数据集
print(val_mae)                                                         # 输出平均错误值

model = models.Sequential()                     # 定义一个连续的网络模型
model.add(layers.Dense(64,
                       activation='relu',
                       input_shape=(13,)))      # 添加一个输入层，并设置激活函数
model.add(layers.Dense(64, activation='relu'))  # 再添加一个网络层
model.add(layers.Dense(1))                      # 添加一个输出层
model.compile(optimizer='sgd', loss='mse', metrics=['mae'])   # 编译模型
model.summary()                                 # 打印模型结构

model.fit(train_data, train_targets, epochs=100, verbose=0)            # 训练数据
val_mse, val_mae = model.evaluate(test_data, test_targets, verbose=0)  # 验证测试数据集
print(val_mae)                                                         # 输出平均错误值

model = models.Sequential()                     # 定义一个连续的网络模型
model.add(layers.Dense(64,
                       activation='relu',
                       input_shape=(13,)))      # 添加一个隐藏层，并设置激活函数
model.add(layers.Dense(64, activation='relu'))  # 再添加一个隐藏层
model.add(layers.Dense(1))                      # 添加一个输出层
model.compile(optimizer='sgd', loss='mse', metrics=['mae'])   # 编译模型

model.fit(train_data, train_targets, epochs=200, verbose=0)            # 训练数据，200次
val_mse, val_mae = model.evaluate(test_data, test_targets, verbose=0)  # 验证测试数据集
print(val_mae)                                                         # 输出平均错误值

import numpy as np

feature = np.array([
  1.23247,		#人均犯罪率	 
  0.0,		#住宅密度 	 
  8.14,		#商业配套 	 
  0.0,		#空气质量 	 
  0.538,		#河流覆盖 	 
  6.142,		#房屋大小 	 
  91.7,		#房屋年龄 	 
  3.9769,		#城区距离 	 
  4.0,		#交通距离 	 
  307.0,		#住宅税率 	 
  21.0,		#教育资源 	 
  396.9,		#人口肤色比例 	 
  18.72		#人口密度
])

feature -= mean
feature /= std
result = model.predict([feature.tolist()])

print(result)